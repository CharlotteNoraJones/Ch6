#include <iostream>

// 6.1 Intro
// Some operations, like == and << have suprising conventions
// Ignore mysterious at your peril!

// // 6.1.1 Essential Operations
// // if a class has a nontrivial destructor, it probably needs constructor, copy, and move

// class X {
//     public:
//         X(Sometype); // "ordinary constructor": create an object
//         X(); // default constructor
//         X(const X&); // copy constructor
//         X(X&&); // move constructor
//         X& operator=(const X&); // copy assignment: clean up target and copy
//         X& operator=(X&&) // move assignment: clean up target and move
//         ~X(); //destructor: clean up
//     // ..
// };

// // 5 sitatuions an object can be copied or movied. 
// // as the source of an assignment
// // as an object initializer
// // as a function argument
// // as a function return value
// // as an exception

// // to optimize, copy or move can be replaced by constructing the object
// // used to initialize right in the target object. 

// X make(Sometype);
// X x = make(value);

// // compiler will construct X from make directly (eliding a copy)

// // constructors
// // initialize objects on free store
// // initialize temp objects
// // implement explicit type conversion

// // special member functions (except "ordinary construct") are generated by the compiler

// // example of explicitly generating default implementations
// class Y{
//     public:
//         Y(Sometype);
//         Y(const Y&) = default; // I really do want the default copy constructor
//         Y(Y&&) = default; // and the default move constructor
//         // ...
// };

// // in the above example, the =default arn't necessary. You're just explicitly telling the compiler
// // to do what it would normally do implicitly

// // be explicit about copy and move when a class has a pointer member. 
// // this is because the pointer could point to something the class has to delete. 
// // in that case, the default memberwise copy would be wrong
// // if the pointer points to something the class shouldn't delete, being explicit informs the reader of this face. 

// // rule of zero: define all essential operations or none(using the default for all)

// // here, the compiler generates default memberwise functions
// struct Z{
//     Vector v;
//     string s;
// }

// Z z1; // default initialize z1.v and z1.s
// Z z2 = z1; // default copy z1.v and z1.s


// // =delete means don't generate the options. 

// class Shape {
//     public: 
//         Shape(const Shape&) = delete; // no copying
//         Shape& operator=(const Shape&) = delete;
//         // ..
// };

// void copy(Shape& s1, const Shape& s2)
// {
//     s1 = s2; // error: Shape copy is deleted
// }

// // =delete makes the deleted function a compile-time error. 
// // =delete can surpress any function

// // 6.1.2 Conversions
// // a constructor taking a single arguement defines a conversion from its argument type. 
// // complex provides a constructor from a double:

// complex z1 = 3.14; // z1 becomes {3.14, 0.0}
// complex z2 = z1*2; // z2 becomes z1*{2.0,0} == {6.28,0.0}

// // implicit conversion sometimes ideal, sometimes isn'

// //constructing a Vector from an int

// Vector v1 = 7; // OK: v1 has 7 elements. 

// // this is usually not ideal, std::vector doesn't allow this

// // the way to only allow explicit conversion
// class Vector {
//     public:
//         explicit Vector(int s); //no implicit conversion from int to Vector
//         // ..
// };

// Vector v1(7); // Ok: v1 has 7 elements
// Vector v2 = 7; // error: no implicit conversion from int to Vector

// // use explicit for constructors that take a single arg unless there's a specific reason not to. 

// // 6.1.3 Member Initializers
// //default member initializer

// class complex {
//     double re = 0;
//     double im = 0; // representation: two doubles with default value 0.0
//     public: 
//         complex(double r, double i) : re{r}, im{i} {} // construct complex from two scalars: {r,i}
//         complex(double r): re{r} {} // construct complex from one scalar: {r, 0}
//         complex() {} //default complex: {0,0}
//         // ,,
// };

// // defualt value is used if the constructor doesn't provide a value

// 6.2 Copy and Move

// by default, both built in and user defined types can be copied. 
// default copy is memberwise copy
// memberwise copy: copy each member

void test(complex z1)
{
    complex z2 {z1}; // copy initialization
    complex z3; 
    z3 = z2; // copy assignment
    // ..
}
// z1, z2, z3 all have the same value
// memberwise copy is usually bad for 
// sophisticated concrete types (like vector)
// abstract types

// 6.2.1 Copying Containers
// resource handle: class is responsible for an object accessed thru a pointer
// default memberwise is bad for resource handles
// memberwise copy violates resource handle's invariant

void bad_copy(Vector v1)
{
    Vector v2 = v1; // copy v1's representation into v2
    v1[0] = 2;  // v2[0] is now also 2!
    v2[1] = 3; // v1[1] is now also 3!
}

// Vector with better copying
// if it has a non-trivial delete, then memberwise copy usually won't work well. 

class Vector {
    public: 
        Vector(int s);                  // constructor: establish invariant, acquire resources
        ~Vector() {delete[] elem;}      // destructor: release resources

        Vector(const Vector& a); // copy constructor
        Vector& operator=(const Vector& a); // copy assignment

        double& operator[](int i);
        const double& operator[](int i) const;

        int size() const;
    private:
        double* elem; // elem points to an array of sz doubles
        int sz;
};

// the copy constructor should allocate space and then copies the elements into the space

Vector::Vector(const Vector& a) // copy constructor
    :elem{new double[a.sz]}, // allocate space for elements
    sz{a.sz}
{
    for (int i=0;i!=sz;++i) // copy elements
        elem[i] = a.elem[i];
}

// copy assignment
Vector& Vector::operator=(const Vector& a) // copy assignment
{
    double* p = new double[a.sz];
    for (int i=0;i!=a.sz;++i)
        p[i] = a.elem[i];
    delete[] elem; // delete old elements
    elem = p;
    sz = a.sz;
    return *this;
}

// this: predefined in a member function, points to object where the member function is defined.
// copy new elements before deleting old ones so that, if an exception occurs, the 
// old value of Vector isn't lost. 

// 6.2.2 Moving Containers
// copying is expensive for big containers
// references avoid the cost of copying, but a reference to a local object
// can't be returned from a function
// that's becaue local objects are destroyed at the end of a function

Vector operator+(const Vector& a, const Vector& b)
{
    if (a.size()!=b.size())
        throw Vector_size_mismatch{};

    Vector res(a.size());

    for (int i=0; i!=a.size(); ++i)
        res[i]=a[i]+b[i];
    return res;
}

// as written above, this function requires copying a vector, which can be expensive. 

// the function might be used like so
void f(const Vector& x, const Vector & y, const Vector& z)
{
    Vector r;
    // ..
    r = x+y+z;
    // ..
}

// function f involves copying a vector at least twice. 

// Vector + rewritten with move

class Vector{
    // ..

    Vector(const Vector& a); //copy constructor
    Vector& operator=(const Vector& a); // copy assignment

    Vector(Vector&& a); // move constructor
    Vector& operator=(Vector&& a); // move assignment
};

// if Vector is defined like above, the compiler will use move
// this means r=x+y+z involves no copying of the vectors

// define Vector's move constructor
Vector::Vector(Vector && a)
    :elem{a.elem}, //"grab the elements" from a
    :sz{a.sz}
{
    a.elem = nullptr; // now a has no elements
    a.sz = 0;
}

// &&: rvalue reference. 
// rvalue: something that can appear on the left-hand side of the assignment
// you can't assign to rvalues.
// since nobody else can assign to it, we can safely steal its value
// res local variable in operator+() is an example

// move constructor does not take a const arg because it's removing value from its arguement
// move assignment is similar

// compiler applies a move operation when an rvalue reference is used as an initializer or as the right-hand 
// of an assignment. 

// post move, moved-from object should be in a state that lets the destructor run. 
// ussually assignment from a moved-from object is allowed

// if a value won't be used again, we inform the compiler

Vector f()
{
    Vector x(1000);
    Vector y(2000);
    Vector z(3000);

    z = x; // we get a copy (x might be used later in f())
    y = std::move(x); // we get a move (move assignment)
    // .. better not use x here ..
    return z; // we get a move
}

// std:: move doens't move anything. it returns a reference to the arguement which which we may move
// it returns an rvalue reference
// thus, it's a kind of cast. 

// when we return from f(), z is destoyed after its elements have been moved out of f() by the return.
// y's destructor will delete its elements

// compiler eliminates most copies associated with initialization
// move constructors are not invoked by the compiler that often
// that's copy elison - it eliminates the overhead of the move.

// usually, can't eliminate copy or move operations from assignments,
// in that case, move matters a lot for performance

// 6.3 Resource Management
// defining constructors, copy operations, move operations, and a desctructor, programmers can control the whole life of a resource. 
// move constructors let an object move simply and cheaply from one scope to another
// moving objects prevents the large overhead of copying. 

// example of this with threads and a really big vector

std::vector<thread> my_threads;

Vector init(int n)
{
    thread t {heartbeat}; // run heartbeat concurrently (in a seperate thread)
    my_threads.push_back(std::move(t)); // move t into my_threads
    // .. more initialization

    Vector vec(n);
    for (auto& x : vec)
        x = 777;
    return vec; // move vec out of init()
}

auto v = init(1`000`000); // start heartbeat and initialize v

// resource handles are better than built-in pointers often
// this allows strong resource safety - eliminating leaks from the general notion of a resouce
// examples: vectors, threads, fstreams

// it's possible to use a garbage collector in C++, but's it best to not make garbage in the first place

//memory is not the only resource
// non-memory resource example: 
// memory, locks, sockets, file handles, and thread handles are examples. 
// leaks are bad, but hanging onto resources can be bad to. 

// let each resource have an owner in some scope and by default be released at the end of owner's scope. 
// that's know as Resouce Acquisition is Initialzation (RAII)
// it's integrated with error handling in the form of exceptions. 
// move resources from scope to scope with smart pointers
// shared ownership should be represented with shared pointers. 

// 6.4 Operator Overloading
// giving meaing to c++ operator's for user-defined types
// can't define new operators
// define operators with conventional semantics. 

//operators can be defined as a member function

class Matrix {
    // ..
    Matrix& operator=(const Matrix& a); // assign m to *this; return a reference to *this"
};

// this is often done for operators that modify their first operand. 
// it's required for =, ->,(), and []

// operators can defined as free-standing functions:
Matrix operator+(const Matrix& m1, const Matrix& m2); // assign m1 to m2 and return sum

// if the operands are symmetrical, defin them as free-standing so that both are treated identically
// to get good performance from returning a large object like a Matrix, rely on move semantics. 

// 6.5 Conventional Operations
// confirm to these when convetions when designing new types
// comparisons: ==, !=, <=, >, >=, and <=>
// container operatios: size(), begin(), and end()
// iterators and "smart pointers": ->, *, [], ++, --, +,-,+=, and -=
// function objects: ()
// input and output operations: >> and <<
// swap()
// hash functions: hash<>

// 6.5.1 Comparisons (Relational Operators)
// equality comparision is related to copying. 
// copies should be equal after copy

X a = something;
X b = a;
assert(a==b); // if a!=b here, something is very odd


// to give identical treatment to both sides of a binary operator, define it as a free-standing function
namespace NX {
    class X {
        // ..
    };
    bool operator==(const X&, const X&);
    // ..
};

// "Spaceship operator" <=> has weird rules
// be defining <=> other relational operators are implicitly defined

class R {
    // ..
    auto operator<=>(const R& a) const = default;
};

void user(R r1, R r2)
{
    bool b1 = (r1<=>r2) == 0; //r1==r2
    bool b2 = (r1<=>r2) < 0; // r1<r2
    bool b3 = (r1<=>r2) > 0; // r1>r2

    bool b4 = (r1==r2);
    bool b5 = (r1<r2);
}

// <=> implements a three way comparison. 
// if <=> is defined as non-default, == is not implicitly defined, but < and other relational operators are

struct R2 {
    int m;
    auto operator<=>(const R2& a) const {return a.m == m ? 0 : a.m < m ? -1 : 1;}
};

// p?x:y returns x p is true, y otherwise. 

void user(R2 r1, R2 r2)
{
    bool b4 = (r1==r2); // error:no non-default ==
    bool b5 = (r1<r2); // Ok
}

// this leads to this pattern of definition for nontrivial types

struct R3{/* ... */};

auto operator<=>(const R3& a, const R3& b) {/* ... */}

bool operator==(const R3*a, const R3& b) {/* ... */}

// most standard library types follow this pattern. 
// becuase:
// if a type has more than one element taking part in the comparison, <=> examines them in lexigraphical order
// it's often worthwhile to provide a seperate optimized == in addition because <=> has to examine all elemenets
// to determine all three alternatives

string s1 = "asdfghjkl";
string s2 = "asdfghjk";

bool b1 = s1==s2; // false
bool b2 = (s1 <=> s2) == 0; // false

// with ==, we can find out that the strings arn't equal by checking their size
// with <=>, the compiler has to check every char in the string. 

// 6.5.2 Container Operations
// design containers in the style of standard-library containers
// make the container resource safe by implementing 
// it as a handle with appropriate essentail operations. 

// the standard library elements know how many elements they have and get it by calling size()

for(size_t i=0; i!=c.size();++i) //size_t is the name of the type returned by a standard-library size()
    c[i]=0;

// std rely on sequences delimited by pairs of iterators instead of the above method

for (auto p = c.begin(); p!=c.end();++p)
    *p=0;

// c.begin() points to the first element of c
// c.end() points one beyond the last element of c
// iterators support ++ to move to the next element and * to access the value of the pointed-to element.

// begin() and end() functions are also used by implementation of range-for
for (auto& x : c)
    x=0;

// iterators are used to pass sequences to standard-library algorithms
sort(v.begin(),v.end());

// this is called the iterator model

// being() and end() can also be defined as free-standing functions
// for const containers, they are called cbegin() and cend()

// 6.5.3 Iterators and "smart pointers"
// user-defined iterators and "smart pointers" implement the operators and aspects
// of a pointer desired for their purpose and often add semantics as needed

// 6.5.4 Input and Output Operations
// for intergers << is left shift and >> is right shift. 
// they are input and output for iostreams. 

// 6.5.5 swap()
// many algorithms (like sort()) are a swap function that changes the value of two objects. 
// std::swap(a,b) is very fast. 
// user-defined types that expensive to copy or can plausibly be swapped should have move operations, swap(), or both

// 6.5.6 hash<>
// std::unordered_map<K,V> is a hash table with K as the key type and V as the value type. 
// to use hash X as a key, we must define hash<X>
// for std::string, the standard library defines hash<> for us. 

// 6.6 User-Defined Literals
// literals can be provided for user-defined types
// do this by defining the suffix for a literal
// for example:
// "Surprise!"s is a std::string
// 123s is seconds
// 12.7i is imaginary so that 12.7i+47 is a complex number (e.i. {47, 12.7})

// import std::literals::string_literals to get s, for example

// user-defined literals/UDLS - literals with user-defined suffixes. 
// literal operator converts a literal of its arguement type, followed by a substricpt, into its return type

// implementation of i for imaginary suffix

constexpr complex<double> operator""i(long double arg) // imaginary literal
{
    return {0, arg};
}
// operator""" indicates that we're defining a literal operator
// i after te literal indicator "" is the suffix which gives the operator a meaning
// long double arg type means the suffix is being defined for a floating point literal
// return type complex<double> specifies the return type of the resulting literal. 

// the implementation in action:
complex<double> z = 2.7182818+6.283185i;

// constexpr means the computation of z's value is done at compile time. 